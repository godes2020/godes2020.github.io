# Модульная архитектура VOID CLICKER

## Структура проекта

```
js/
├── config/                    # Конфигурационные файлы
│   ├── abilities.js          # Конфигурация способностей
│   ├── achievements.js       # Конфигурация достижений
│   ├── constants.js          # Базовые константы игры
│   ├── recipes.js            # Рецепты крафта и материалы
│   └── upgrades.js           # Конфигурация апгрейдов
│
├── game/                      # Игровая логика
│   ├── Game.js               # Главный класс-оркестратор
│   ├── GameState.js          # Управление состоянием
│   └── Energy.js             # Система энергии
│
├── storage/                   # Сохранение и загрузка
│   └── StorageManager.js     # localStorage и API
│
├── utils/                     # Вспомогательные утилиты
│   ├── formatters.js         # Форматирование чисел
│   └── helpers.js            # Вспомогательные функции
│
└── main.js                    # Точка входа приложения
```

## Архитектура

### Главные компоненты

#### 1. Game Class (game/Game.js)
Главный класс-координатор, который:
- Инициализирует все модули
- Управляет игровым циклом
- Координирует сохранение/загрузку
- Обрабатывает игровые события (клики, и т.д.)

```javascript
import { Game } from './game/Game.js';
const game = new Game();
await game.init();
```

#### 2. GameState Class (game/GameState.js)
Централизованное хранилище состояния:
- Хранит все данные игры (золото, энергия, апгрейды и т.д.)
- Предоставляет методы export/import для сохранения
- Инициализирует начальное состояние

#### 3. StorageManager (storage/StorageManager.js)
Управление сохранением:
- Сохранение в localStorage
- Сохранение на сервер через API
- Загрузка из localStorage
- Загрузка с сервера через API

#### 4. Energy (game/Energy.js)
Система энергии:
- Автоматическая регенерация
- Трата энергии
- Обновление UI

### Конфигурационные модули

Все константы и настройки вынесены в отдельные файлы в `config/`:
- **abilities.js** - настройки способностей (урон, кулдаун, требования)
- **achievements.js** - список всех достижений
- **constants.js** - базовые константы (интервалы, стоимости)
- **recipes.js** - рецепты крафта и материалы
- **upgrades.js** - конфигурация апгрейдов

### Утилиты

Вспомогательные функции в `utils/`:
- **formatters.js** - форматирование чисел (1000 → 1.00K)
- **helpers.js** - проверка частоты кликов, всплывающий текст

## Использование

### Инициализация игры

```javascript
import { Game } from './game/Game.js';

const game = new Game();
await game.init(); // Загружает сохранение и запускает системы
```

### Обработка событий

```javascript
// Клик игрока
game.playerClick(event);

// Сохранение игры
await game.saveGame();

// Остановка игры
game.stop();
```

### Доступ к состоянию

```javascript
// Чтение состояния
console.log(game.state.gold);
console.log(game.state.energy);

// Изменение состояния
game.state.gold += 100;
game.state.energy -= 1;
```

## Преимущества модульной архитектуры

1. **Разделение ответственности** - каждый модуль отвечает за свою функцию
2. **Переиспользование кода** - модули можно использовать в других проектах
3. **Легкость тестирования** - каждый модуль можно тестировать отдельно
4. **Масштабируемость** - легко добавлять новые модули
5. **Читаемость** - код организован логически

## Что осталось сделать

### Модули, которые нужно создать:
- [ ] Combat.js - логика боя и способностей
- [ ] Upgrades.js - система апгрейдов
- [ ] Crafting.js - система крафта
- [ ] Achievements.js - проверка достижений
- [ ] Rebirth.js - система перерождения
- [ ] UIManager.js - управление UI
- [ ] Renderer.js - рендеринг вкладок
- [ ] Notifications.js - toast уведомления

### Интеграция:
- [ ] Обновить index.html для использования модулей
- [ ] Перенести оставшиеся функции из game-script-new.js
- [ ] Добавить обработчики событий
- [ ] Протестировать все системы

## Миграция со старой версии

Старая версия (game-script-new.js) использовала:
- Глобальные переменные
- Один большой файл
- Функции вместо классов

Новая версия использует:
- ES6 модули (import/export)
- Классы для инкапсуляции
- Разделение по функциональности

Оба подхода совместимы с одним и тем же форматом сохранений.
